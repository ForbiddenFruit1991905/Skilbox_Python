# Задача 1. Работа с файлом
# Вы пишете небольшое приложение для работы с файлами. Реализуйте функцию,
# которая может принимать на вход три аргумента: вопрос пользователю (на
# который нужно ответить да или нет), сообщение о неправильном вводе и
# количество попыток. Вопрос — обязательный позиционный аргумент, остальные
# — со значениями по умолчанию. При корректном ответе функция может возвращать
# что угодно — например, число 1 при ответе «да» или 0 при ответе «нет».
# В основной программе вызовите функцию минимум три раза: только с вопросом,
# с вопросом и сообщением об ошибке, с вопросом и количеством попыток.
# Пример работы программы:
# Вы действительно хотите выйти? что
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 3
# Вы действительно хотите выйти?
# Удалить файл? не знаю
# Так удалить или нет?
# Осталось попыток: 3
# Удалить файл? нет
# Записать файл? ага
# Неверный ввод. Пожалуйста, введите 'да' или 'нет'.
# Осталось попыток: 1
# Записать файл? да

# def func_files(question, condition='Вы ввели неправильное значение. Попробуйте еще раз.', attempts=3):
#     while True:
#         answer = input(f"{question} Да или нет? ")
#         if answer == 'да':
#             return 1
#         elif answer == 'нет':
#             return 0
#         else:
#             print(condition)
#         attempts -= 1
#         print(f'Осталось попыток: {attempts}')
#         if attempts == 0:
#             print('Количество попыток иссякло.')
#             break
#
#
# result_1 = func_files('Сохранить файл?')
# result_2 = func_files('Удалить файл?', condition='Так удалить или нет?')
# result_3 = func_files('Вырезать файл из папки?', attempts=4)


# Задача 2. Накопление значений
# При работе со значениями по умолчанию и изменяемыми типами данных нужно знать
# и остерегаться ещё одной интересной штуки.
# Напишите функцию с двумя аргументами: первый — число num, позиционный аргумент;
# второй — список lst, по умолчанию он пустой. В теле функции в список добавляется
# число num и сам список выводится на экран.
# В основной программе вызовите функции три раза только с одним аргументом (числом),
# например так:
# add_num(5)
# add_num(10)
# add_num(15)
# И посмотрите, что произойдёт.
# После этого сделайте значение lst по умолчанию None и поправьте функцию, чтобы она работала правильно.

# def add_num(num, lst=None):
#     if lst is None:
#         lst = []
#     lst.append(num)
#     print(lst)
#
#
# add_num(5)
# add_num(10)
# add_num(15)
# add_num(15)


# Задача 3. Помощь другу
# Нашего друга попросили написать функцию, которая на вход принимает список всякого мусора.
# Ему нужно подготовить из этого списка список словарей, чтобы его коллеги смогли дальше
# продолжить обработку данных. Вот список правил, что нужно сделать с изначальным списком:
# Если в списке встретился словарь, то оставляем его.
# Если в списке встретилась строка, то из неё нужно сделать словарь и положить его в итоговый
# список, например  “abc” → {“abc”: “abc”}.
# С числами нужно сделать то же самое, что и со строками.
# Всё остальное выкидываем из нашего списка.
# Друг написал программу, но в ней ошибка, так как она что-то не то выводит. Исправьте программу
# и убедитесь, что всё работает верно.

def create_dict(some_data, template=None):
    if template is None:
        template = dict()
    if isinstance(some_data, dict):
        return some_data
    elif isinstance(some_data, (int, float, str)):
        template[some_data] = some_data
        return template
    else:
        return None


def data_preparation(old_list):
    new_list = []
    for i_element in old_list:
        result = create_dict(i_element)
        if result is not None:
            new_list.append(result)
    return new_list


data = ['sad', {'sds': 23}, {43}, [12, 42, 1], 2323]
data = data_preparation(data)
print(data)
