# def binary_search(arr, x, start, end):
    # arr — список всех элементов;
    # x — элемент, который мы ищем;
    # start — первый индекс;
    # end — последний индекс;
    # то есть start/end — границы поиска внутри списка.
    # if start > end:
#         # Если начальный индекс больше конечного, то элемент не найден, возвращаем -1.
#         # Это будет значить, что мы не нашли нужное число.
#         return - 1
#     # Иначе находим индекс среднего элемента.
#     mid = (start + end) // 2
#     if arr[mid] == x:
#         # Если средний элемент равен искомому элементу, то возвращаем его индекс.
#         return mid
#     elif arr[mid] < x:
#         # Если средний элемент меньше искомого элемента, то ищем элемент во второй половине списка (после среднего элемента).
#         return binary_search(arr, x, mid + 1, end)
#     else:
#         # Если средний элемент больше искомого элемента, то ищем элемент в первой половине списка (до среднего элемента).
#         return binary_search(arr, x, start, mid - 1)
#
#
# arr = [2, 3, 4, 10, 40]
# x = 10
# result = binary_search(arr, x, 0, len(arr) - 1)
# if result != -1:
#     print(f"Элемент найден в индексе {result}")
# else:
#     print("Элемент не найден")


import copy
def deep_copy(obj):
    if isinstance(obj, (int, float, bool, str)):
        # Если объект относится к простому типу данных (число, строка, булевое значение), то он возвращается как есть, так как не может иметь вложенных объектов.
        return obj
    elif isinstance(obj, list):
        # Если объект представляет собой список, то создаётся новый список, содержащий копии всех элементов исходного списка.
        # При этом для каждого элемента списка рекурсивно вызывается функция deep_copy(), чтобы скопировать его содержимое.
        return [deep_copy(item) for item in obj]
    elif isinstance(obj, dict):
        # Если объект — это словарь, то создаётся новый словарь, содержащий копии всех элементов исходного словаря, так же с вызовом deep_copy для каждого вложенного объекта.
        return {key: deep_copy(value) for key, value in obj.items()}
    else:
        # Если объект не относится к базовому типу и не является списком или словарём, используется метод copy.deepcopy() из стандартной библиотеки Python, чтобы создать глубокую копию.
        return copy.deepcopy(obj)