# Реализуйте модернизированную версию контекст-менеджера File:
# теперь при попытке открыть несуществующий файл менеджер должен автоматически
# создавать и открывать этот файл в режиме записи;
# на выходе из менеджера должны подавляться все исключения, связанные с файлами.
# Что оценивается
# Результат вычислений корректен.
# Модели реализованы в стиле ООП, основной функционал описан в методах классов и
# отдельных функциях.
# При написании классов соблюдаются основные принципы ООП: инкапсуляция, наследование
# и полиморфизм.
# Для получения и установки значений приватных атрибутов используются сеттеры и геттеры
# с соответствующими декораторами.
# Для создания нового класса на основе уже существующего используется наследование.
# Для статических и классовых методов используется декоратор classmethod.
# Сообщения о процессе получения результата осмысленны и понятны для пользователя.
# Переменные, функции и собственные методы классов имеют значащие имена (не a, b, c, d).
# Классы и методы/функции имеют прописанную документацию.
# Есть аннотация типов для методов/функций и их аргументов (кроме args и kwargs). Если
# функция/метод ничего не возвращает, то используется None.

class File:

    def __init__(self, file, is_exist):
        self.file = file
        self.is_exist = is_exist
        self.file_to_open = None

    def __enter__(self):
        try:
            self.file_to_open = open(self.file, self.is_exist, encoding='utf-8')
        except IOError:
            self.file_to_open = open(self.file, 'w')

        return self.file_to_open

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file_to_open:
            self.file_to_open.close()
        if exc_type and issubclass(exc_type, IOError):
            return True


with File('example.txt', 'w') as file_to_open:
    file_to_open.write('Всем привет!')

